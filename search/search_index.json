{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>In this lab, you will start by developing a client application that produces evidence, in the form of authorization proofs, that a remote server should grant access to certain resources. As such, you will implement a theorem prover for the constructive authorization logic that we have discussed in lecture. However, your goal is not to implement a theorem prover that can prove any valid formula, but rather a limited set of formulas that make use of three authorization policies. To help you get started with this, a set of tactics, or modular techniques for making progress on finding proofs, are provided for you to work with and draw ideas from.</p> <p>Having implemented the client, you will turn your attention to the authorization server, whose source is included in this repository. It contains a vulnerability, having to do with the way that it authenticates evidence sent by the client, that allows anyone to (erroneously) convince it that they should be granted access to any resource of their choice. You will identify the vulnerability, and demonstrate your understanding of it by implementing an exploit that causes the server to send you a credential to a forbidden resource.</p>"},{"location":"#learning-goals","title":"Learning goals","text":"<ul> <li>Understand the core techniques that are used to automatically prove theorems like those needed for the authorization logic discussed in lecture.</li> <li>Gain experience designing customized automated reasoning techniques for specific instances of authorization policies.</li> <li>Develop familiarity with public-key authentication and how certificate authorities are used to establish trust.</li> <li>Gain experience identifying flaws in code that deals with authentication decisions, and developing exploits that leverage such flaws.</li> </ul>"},{"location":"#what-to-hand-in","title":"What to hand in","text":"<p>Submit your work on Gradescope. Create a <code>zip</code> archive of the repository, but make sure that you have not included the directory <code>lab1-2022</code> at the root of the archive. Additionally, there is no need to hand in test cases or files in <code>src/__pycache__</code>, and doing so may slow down processing by the autograder.</p> <p>You are encouraged to use the <code>handin.sh</code> script, which will create an appropriate archive in <code>handin.zip</code> to upload to Gradescope. This script will not work when run from Windows' <code>cmd.exe</code> or Powershell, but you may translate it to use native Windows commands if you are not already using the WSL2 setup described at the top of this readme.</p>"},{"location":"#evaluation","title":"Evaluation","text":"<p>This lab is worth 100 points, and will be graded by a combination of autograder test cases and, when necessary, manual inspection by the course staff. The test cases will use the same delegation policies described in this handout, but with a different set of credentials than those in this repository. We will also test your exploit in <code>exploit.py</code>, and ensure that the exploit is not used as a tactic by your prover.</p> <p>The percentage breakdown is as follows. * 25 points for a successful proof of <code>open(#andrewid, &lt;andrewid.txt&gt;)</code> * 25 points for a successful proof of <code>open(#andrewid, &lt;shared.txt&gt;)</code> * 25 points for a successful proof of <code>open(#andrewid, &lt;secret.txt&gt;)</code> * 25 points for an exploit that results in <code>open(#andrewid, &lt;bigsecret.txt&gt;)</code></p> <p>We will additionally check that the credentials used by your proofs for the top three bullets are minimal, i.e., that the access requests generated by your proofs do not send more credentials and certificates than are necessary to make the authorization claim. Proofs that use more credentials than are necessary will recieve 80% of the credit allotted by the corresponding bullet above.</p>"},{"location":"auth/","title":"Authorization mechanics","text":"<p>An authorization server is running on port <code>15316</code> at <code>authproof.net</code>. Its job is to accept credentials and authorization proofs, verify them, and provide new credentials that allow clients to access resources that the server controls. It functions in the following way.</p> <ol> <li>When a client connects on port <code>15316</code>, it expects to recieve an <code>AccessRequest</code> object (defined in <code>crypto.py</code>) containing a signed request for a named resource on behalf of a user, a proof that the user is allowed to access that resource, and any credentials and certificates needed to verify that the proof is correct.</li> <li>The server calls <code>verify_request</code> (in <code>crypto.py</code>) on this access request.</li> <li>If the request can be verified, then the server returns a new credential signed by <code>#root</code> granting access to the requested resource.</li> <li>Otherwise, the server returns an error message.</li> </ol> <p>The client is implemented in <code>auth.py</code>.</p> <pre><code>usage: auth.py [-h] [-s] requester resource\n\nConstructs an authorization request, with proof. Optionally sends the request to the authorization server.\n\npositional arguments:\n  requester           agent making the request (use your andrew id)\n  resource            resource under request (either shared.txt or andrewid.txt)\n\noptions:\n  -h, --help          show this help message and exit\n  -s, --send_request  send the request to the authorization server\n</code></pre> <p>Running the command <code>python src/auth.py andrewid andrewid.txt</code> will cause the following to happen.</p>"},{"location":"auth/#step-1-gather-credentials","title":"Step 1: Gather credentials","text":"<p>The client will first populate a sequent with a proof goal, filling the context with all of the certificates in <code>certs</code> and credentials in <code>cred</code>.</p> <pre><code>ca(#ca) true,\niskey(#ca, [43:c9:43:e6]) true,\nsign((iskey(#mdhamank, [71:14:55:85])), [43:c9:43:e6]) true,\nsign((iskey(#mfredrik, [d3:c6:2a:1b])), [43:c9:43:e6]) true,\nsign((iskey(#root, [2b:8f:e8:9b])), [43:c9:43:e6]) true,\nsign((iskey(#dsduena, [db:b2:b9:b7])), [43:c9:43:e6]) true,\nsign((iskey(#justinyo, [d2:15:e7:01])), [43:c9:43:e6]) true,\nsign((open(#andrewid, &lt;andrewid.txt&gt;)), [71:14:55:85]) true,\nsign((open(#andrewid, &lt;shared.txt&gt;)), [d3:c6:2a:1b]) true,\nsign((open(#andrewid, &lt;andrewid.txt&gt;)), [2b:8f:e8:9b]) true,\nsign((open(#dsduena, &lt;andrewid.txt&gt;)), [d3:c6:2a:1b]) true,\nsign((open(#justinyo, &lt;andrewid.txt&gt;)), [db:b2:b9:b7]) true,\nsign((open(#mdhamank, &lt;andrewid.txt&gt;)), [d2:15:e7:01]) true,\nsign((open(#mfredrik, &lt;andrewid.txt&gt;)), [2b:8f:e8:9b]) true,\nsign((open(#mfredrik, &lt;shared.txt&gt;)), [2b:8f:e8:9b]) true,\nsign(((@A . (((#mfredrik says open(A, &lt;shared.txt&gt;)) -&gt; open(A, &lt;shared.txt&gt;))))), [2b:8f:e8:9b]) true,\nsign(((@A . ((@R . ((open(A, R) -&gt; (@B . (((A says open(B, R)) -&gt; open(B, R)))))))))), [2b:8f:e8:9b]) true,\nsign((open(#siruih, &lt;andrewid.txt&gt;)), [71:14:55:85]) true\n    |-  (#root says open(#andrewid, &lt;andrewid.txt&gt;)) true\n</code></pre> <p>Each credential is added as a <code>sign(open(...), [...])</code> formula. The credentials in this example are shown below.</p> <pre><code>sign((open(#andrewid, &lt;andrewid.txt&gt;)), [71:14:55:85]) true,\nsign((open(#andrewid, &lt;shared.txt&gt;)), [d3:c6:2a:1b]) true,\nsign((open(#andrewid, &lt;andrewid.txt&gt;)), [2b:8f:e8:9b]) true,\nsign((open(#dsduena, &lt;andrewid.txt&gt;)), [d3:c6:2a:1b]) true,\nsign((open(#justinyo, &lt;andrewid.txt&gt;)), [db:b2:b9:b7]) true,\nsign((open(#mdhamank, &lt;andrewid.txt&gt;)), [d2:15:e7:01]) true,\nsign((open(#mfredrik, &lt;andrewid.txt&gt;)), [2b:8f:e8:9b]) true,\nsign((open(#mfredrik, &lt;shared.txt&gt;)), [2b:8f:e8:9b]) true,\nsign(((@A . (((#mfredrik says open(A, &lt;shared.txt&gt;)) -&gt; open(A, &lt;shared.txt&gt;))))), [2b:8f:e8:9b]) true,\nsign(((@A . ((@R . ((open(A, R) -&gt; (@B . (((A says open(B, R)) -&gt; open(B, R)))))))))), [2b:8f:e8:9b]) true,\nsign((open(#siruih, &lt;andrewid.txt&gt;)), [71:14:55:85]) true\n</code></pre> <p>Each certificate is added as a <code>sign(iskey(...), [...])</code> formula, shown below.</p> <pre><code>sign((iskey(#mdhamank, [71:14:55:85])), [43:c9:43:e6]) true,\nsign((iskey(#mfredrik, [d3:c6:2a:1b])), [43:c9:43:e6]) true,\nsign((iskey(#root, [2b:8f:e8:9b])), [43:c9:43:e6]) true,\nsign((iskey(#dsduena, [db:b2:b9:b7])), [43:c9:43:e6]) true,\nsign((iskey(#justinyo, [d2:15:e7:01])), [43:c9:43:e6]) true\n</code></pre> <p>The certificate authority and their key are added to the assumptions.</p> <pre><code>ca(#ca) true,\niskey(#ca, [43:c9:43:e6]) true,\n</code></pre> <p>Each certificate is added as a <code>sign(iskey(...))</code> formula, signed with the key of <code>#ca</code>. So the example certificate for <code>#root</code> shown above would become the following assumption.</p> <pre><code>sign(\n    iskey(#root, [88:02:3f:fb:03:0f:c8:54:dc:75:f0:8e:cc:c3:54:22]),\n    [68:d7:6c:b7:95:fb:a4:f7:a7:4f:12:44:6f:27:c5:40]\n)\n</code></pre> <p>Finally, the following assumptions are always added, to establish that <code>#ca</code> is the trusted certificate authority, and that their key is already known.</p> <pre><code>ca(#ca)\niskey(#ca, [68:d7:6c:b7:95:fb:a4:f7:a7:4f:12:44:6f:27:c5:40])\n</code></pre> <p>Finally, the request is reflected in the goal of the sequent. Namely, the user <code>#andrewid</code> requests access to <code>&lt;andrewid.txt&gt;</code>, and aims to show that this is authorized under <code>#root</code>'s policy.</p> <pre><code>(#root says open(#andrewid, &lt;andrewid.txt&gt;)) true\n</code></pre>"},{"location":"auth/#step-2-call-the-prover","title":"Step 2: Call the prover","text":"<p>The <code>prove</code> function in <code>prover.py</code> is called on this sequent. It either returns a proof or <code>None</code>.</p> <p>If the prover returns <code>None</code>, then the client prints a message and exits. Otherwise, the client begins generating a request to send to <code>authproof.net</code>.</p>"},{"location":"auth/#step-3-send-the-request","title":"Step 3: Send the request","text":"<p>With a proof in hand, the client calls <code>generate_request</code> (in <code>auth.py</code>). <code>generate_request</code> inspects the proof, and determins which credentials and certificates are needed to verify the proof. In this example, only the credential in <code>andrewid_txt.cred</code>, which is signed by <code>#root</code> to state that <code>#andrewid</code> can open <code>&lt;andrewid.txt&gt;</code>, is needed. Likewise, the only certificates that are needed are those of <code>#andrewid</code>, <code>#root</code>, and <code>#ca</code>. It gathers these resources to attach to the request, signs the request with <code>#andrewid</code>'s secret key, and sends the request to the server.</p> <p>The full request for this example is shown below.</p> <pre><code>signature:\n*********************************** Credential ***********************************\nstatement: (#root says open(#andrewid, &lt;andrewid.txt&gt;))\nsignator: #andrewid\nsignature: [ef:63:cb:70:64:52:38:33:16:e6:88:e5:41:11:de:f7]\n**********************************************************************************\n\ncredentials:\n*********************************** Credential ***********************************\nstatement: open(#andrewid, &lt;andrewid.txt&gt;)\nsignator: #root\nsignature: [50:f0:40:3d:91:31:f3:ec:d2:99:bd:e6:b5:6c:8b:02]\n**********************************************************************************\n\ncertificates:\n============================= Public Key Certificate =============================\nkey: [43:c9:43:e6:28:37:ec:23:1a:bc:83:c6:eb:87:e8:6f]\nagent: #ca\n*********************************** Credential ***********************************\nstatement: iskey(#ca, [43:c9:43:e6:28:37:ec:23:1a:bc:83:c6:eb:87:e8:6f])\nsignator: #ca\nsignature: [4a:89:91:6e:c8:18:f2:d1:4c:c6:a0:b6:e8:cb:bf:44]\n**********************************************************************************\n==================================================================================\n============================= Public Key Certificate =============================\nkey: [2b:8f:e8:9b:8b:76:37:a7:3b:7e:85:49:9d:87:7b:3b]\nagent: #root\n*********************************** Credential ***********************************\nstatement: iskey(#root, [2b:8f:e8:9b:8b:76:37:a7:3b:7e:85:49:9d:87:7b:3b])\nsignator: #ca\nsignature: [ac:84:67:26:09:c2:c0:39:0e:0a:13:70:f4:d7:3e:d2]\n**********************************************************************************\n==================================================================================\n============================= Public Key Certificate =============================\nkey: [a2:56:e9:a5:c0:56:d9:32:7a:f1:5b:cb:ce:7a:13:47]\nagent: #andrewid\n*********************************** Credential ***********************************\nstatement: iskey(#andrewid, [a2:56:e9:a5:c0:56:d9:32:7a:f1:5b:cb:ce:7a:13:47])\nsignator: #ca\nsignature: [79:56:b9:1e:0d:a3:fd:4c:2e:72:f2:04:c3:38:fc:cb]\n**********************************************************************************\n==================================================================================\n</code></pre>"},{"location":"auth/#step-4-the-response","title":"Step 4: The response","text":"<p>If the server is able to verify that each certificate and credential was properly signed, and that the proof is correct, then it sends a fresh new credential signed by <code>#root</code> authorizing <code>#andrewid</code> to open <code>&lt;andrewid.txt&gt;</code>.</p> <pre><code>*********************************** Credential ***********************************\nstatement: open(#andrewid, &lt;andrewid.txt&gt;)\nsignator: #root\nsignature: [50:f0:40:3d:91:31:f3:ec:d2:99:bd:e6:b5:6c:8b:02]\n**********************************************************************************\n</code></pre>"},{"location":"auth/#next-steps","title":"Next steps","text":"<p>In the starter code, <code>prover.prove</code> always returns <code>None</code>. Your main job is to implement the prover.</p> <p>You do not need to change anything in <code>auth.py</code>, but it is good to understand how requests are generated and sent, and the role that your prover plays in this process.</p>"},{"location":"exploit/","title":"Exploiting a vulnerability","text":"<p>When you use <code>auth.py</code> to send an authorization request to the server, the server calls <code>verify_request</code> to check the credentials and certificates in your request, and ultimately verifies your authorization proof. However, there is a bug in this implementation that can be exploited to allow anybody to convince the server to verify arbitrary access requests.</p> <p>Familiarize yourself with this code, particularly the implementation of <code>verify_request</code>, to identify the vulnerability. Then provide an implementation of <code>generate_exploit</code> in <code>src/exploit.py</code> that exploits the vulnerability by constructing an <code>AccessRequest</code> for the resource <code>&lt;bigsecret.txt&gt;</code> that the server will successfully verify. </p> <p>You will know that you have completed this task when the server returns the appropriate credential, as shown below (<code>#andrewid</code> will be replaced by your ID).</p> <pre><code>************************ Credential ************************\nstatement: open(#andrewid, &lt;bigsecret.txt&gt;)\nsignator: #root\nsignature: [63:7f:5f:b7:11:4e:b8:e7:55:dd:96:01:8d:13:88:75]\n************************************************************\n</code></pre> <p>To see how <code>AccessRequest</code> objects are made, consult the documentation for <code>AccessRequest.make_for_proof</code> in <code>crypto.py</code>. You will need: * A proof of <code>|- #root says open(#andrewid, &lt;bigsecret.txt&gt;)</code> * The set of credentials needed to prove the above sequent, as <code>Credential</code> objects. * The set of certificates needed to verify the credentials needed for the request.</p> <p>Note that the credentials provided with the lab will not allow you to prove the sequent listed above. As part of this exploit, you will need to generate one or more credentials and possibly one or more new certificates.</p> <ul> <li>Credentials are constructed by <code>Credential.from_formula</code>. Given a formula <code>P</code> and agent <code>#A</code>, calling <code>Credential.from_formula(P, #A)</code> will return a <code>Credential</code> object representing the signature of <code>P</code> with the private key of <code>#A</code>. The only private key that you have access to is your own, and you should be able to complete the task by calling <code>from_formula</code> to sign with your own agent.</li> <li>Certificates are constructed by calling <code>Certificate.make_for_key</code> with three arguments: a public key to create the certificate for, an agent to associate with the public key, and an agent whose private key will be used to sign the certificate.</li> <li>You can also generate new users, with private keys stored locally in <code>private_keys</code>, by calling <code>new_user</code> in <code>src/crypto.py</code>. For example, calling <code>new_user(Agent('#andrew'), Agent('#mfredrik'))</code> will create an agent called <code>#andrew</code>, with a private key stored in <code>private_keys/andrew.pem</code>, and a certificate stored in <code>certs/andrew.cert</code>. The certificate will be signed with the private key of <code>#mfredrik</code>, so in order for this call to succeed, <code>mfredrik.pem</code> must be in the <code>private_keys</code> directory. This means that you can make new agents with certificates signed by your private key, but because you do not have private keys for <code>#ca</code> or <code>#root</code>, calling <code>new_user(Agent('#ca'), Agent('#ca'))</code> will fail. However, <code>new_user</code> does allow you to create a new user with a self-signed certificate, so calling <code>new_user(Agent('#andrew'), Agent('#andrew'))</code> will succeed, and will result in <code>andrew.cert</code> and <code>andrew.pem</code> being placed in the appropriate directories as described above.</li> </ul> <p>You will also find code that generates <code>AccessRequest</code> objects in <code>generate_request</code>, in <code>auth.py</code>. You may be able to use this function to construct the request, but it may be more straightforward to use the code in that function as an example to work from.</p> Example API usage  To recap the APIs for creating credentials and agents described above, suppose that an agent `#andrew` (hypothetically) wished to use a policy which required that the \"normal\" certificate authority, `#ca`, in addition to their own \"private\" authority `#andrew_ca`, *both* issued certificates for a key before they were willing to trust it. `#andrew` would begin by constructing a new agent to represent their private CA:  <pre><code>private_ca = new_user(Agent('#andrew_ca'), Agent('#andrew_ca'))\n</code></pre>  To have the private CA sign `#scotty`'s public key, they would load `#scotty`'s public key from their existing certificate, and construct a new certificate by signing it with the private CA's key:  <pre><code>scotty_normal_cert = Certificate.load_certificate(Agent('#scotty'))\nscotty_private_cert = Certificate.make_for_key(scotty_normal_cert.public_key, Agent('#scotty'), Agent('#andrew_ca'))\n</code></pre>  This would yield a new certificate, stored in `scotty_private_cert`:  <pre><code>============================= Public Key Certificate =============================\nkey: [ae:dc:02:99:da:01:bd:ca:09:5f:6b:c8:90:b2:ff:e0]\nagent: #scotty\n*********************************** Credential ***********************************\nstatement: iskey(#scotty, [ae:dc:02:99:da:01:bd:ca:09:5f:6b:c8:90:b2:ff:e0])\nsignator: #andrew_ca\nsignature: [c9:b7:6c:35:1f:22:9d:35:27:78:5a:2b:86:09:59:c6]\n**********************************************************************************\n==================================================================================\n</code></pre>  `#andrew` might give them a credential that they are allowed to open a resource, created using `Credential.from_formula`:  <pre><code>scotty_cred = Credential.from_formula(parse('open(#scotty, &lt;res&gt;)'), Agent('#andrew'))\n</code></pre>  With this credential, `#scotty` could prove that they are able to access ``, according to `#andrew`'s policy, and construct an access request that contains all of the necessary credentials.  <pre><code>pf = prove(parse('ca(#ca), ca(#andrew_ca), ... |- #andrew says open(#scotty, &lt;res&gt;)'))\nandrew_cert = Certificate.load_certificate(Agent('#andrew'))\nnormal_ca = Certificate.load_certificate(Agent('#ca'))\nrequest = AccessRequest.make_for_proof(pf, Agent('#scotty'), [scotty_cred], [scotty_normal_cert, scotty_private_cert, andrew_cert, normal_ca, private_ca])\n</code></pre>  This would yield the following access request.  <pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Request &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\nsignature:\n*********************************** Credential ***********************************\nstatement: (#andrew says open(#scotty, &lt;res&gt;))\nsignator: #scotty\nsignature: [6b:84:0b:93:b8:9d:a9:1b:3b:0b:52:96:0e:e2:d7:b3]\n**********************************************************************************\n\ncredentials:\n*********************************** Credential ***********************************\nstatement: open(#scotty, &lt;res&gt;)\nsignator: #andrew\nsignature: [94:92:3c:37:a5:65:ec:c4:a5:8c:71:6a:37:9d:45:73]\n**********************************************************************************\n\ncertificates:\n============================= Public Key Certificate =============================\nkey: [68:d7:6c:b7:95:fb:a4:f7:a7:4f:12:44:6f:27:c5:40]\nagent: #ca\n*********************************** Credential ***********************************\nstatement: iskey(#ca, [68:d7:6c:b7:95:fb:a4:f7:a7:4f:12:44:6f:27:c5:40])\nsignator: #ca\nsignature: [52:9d:bf:45:d3:78:be:73:c0:33:57:b8:9f:df:fe:ca]\n**********************************************************************************\n==================================================================================\n============================= Public Key Certificate =============================\nkey: [09:e7:53:10:07:50:de:25:7f:bc:9f:f2:94:b1:51:7f]\nagent: #andrew_ca\n*********************************** Credential ***********************************\nstatement: iskey(#andrew_ca, [09:e7:53:10:07:50:de:25:7f:bc:9f:f2:94:b1:51:7f])\nsignator: #andrew_ca\nsignature: [97:3c:4c:c4:70:12:cb:5f:2b:fb:04:11:9f:4c:40:c0]\n**********************************************************************************\n==================================================================================\n============================= Public Key Certificate =============================\nkey: [62:da:f9:fd:d6:6d:89:62:cc:f7:65:f4:5d:6f:e3:cb]\nagent: #andrew\n*********************************** Credential ***********************************\nstatement: iskey(#andrew, [62:da:f9:fd:d6:6d:89:62:cc:f7:65:f4:5d:6f:e3:cb])\nsignator: #ca\nsignature: [df:3c:72:1f:2e:1a:41:6b:31:34:e7:8e:b3:fc:88:ef]\n**********************************************************************************\n==================================================================================\n============================= Public Key Certificate =============================\nkey: [5a:e0:7b:85:39:93:da:aa:e9:c3:ec:13:4c:f5:46:81]\nagent: #scotty\n*********************************** Credential ***********************************\nstatement: iskey(#scotty, [5a:e0:7b:85:39:93:da:aa:e9:c3:ec:13:4c:f5:46:81])\nsignator: #ca\nsignature: [48:e6:7f:c7:38:a5:4b:d2:49:dc:0d:62:0e:d3:44:92]\n**********************************************************************************\n==================================================================================\n============================= Public Key Certificate =============================\nkey: [5a:e0:7b:85:39:93:da:aa:e9:c3:ec:13:4c:f5:46:81]\nagent: #scotty\n*********************************** Credential ***********************************\nstatement: iskey(#scotty, [5a:e0:7b:85:39:93:da:aa:e9:c3:ec:13:4c:f5:46:81])\nsignator: #andrew_ca\nsignature: [b0:8a:f0:35:a4:ec:60:57:e6:9b:04:15:b8:0a:35:05]\n**********************************************************************************\n==================================================================================\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n</code></pre>"},{"location":"implementation/","title":"Authorization goals","text":"<p>Your primary objective in the lab is to implement a prover that construct authorization proofs for three policies.</p>"},{"location":"implementation/#principals-and-high-level-policies","title":"Principals and high-level policies","text":"<p>The environment that these policies assume includes the following agents:</p> <ul> <li><code>#ca</code>: the certificate authority</li> <li><code>#root</code>: the agent who ultimately provisions authorization</li> <li><code>#mfredrik</code>: authorized by <code>#root</code> to open <code>&lt;shared.txt&gt;</code> and <code>&lt;secret.txt&gt;</code></li> <li><code>#dsduenas</code>: authorized by <code>#mfredrik</code> to open <code>&lt;secret.txt&gt;</code></li> <li><code>#justinyo</code>: authorized by <code>#dsduenas</code> to open <code>&lt;secret.txt&gt;</code></li> <li><code>#mdhamank</code>: authorized by <code>#justinyo</code> to open <code>&lt;secret.txt&gt;</code></li> <li><code>#suruih</code>: authorized by <code>#mdhamank</code> to open <code>&lt;secret.txt&gt;</code></li> <li><code>#andrewid</code>: everyone in the class is authorized by <code>#root</code> to open <code>&lt;andrewid.txt&gt;</code>, by <code>#mfredrik</code> to open <code>#shared</code>, and by <code>#suruih</code> to open <code>&lt;secret.txt&gt;</code>.</li> </ul>"},{"location":"implementation/#the-details","title":"The details","text":"<p>You will first prove that you are able to open <code>&lt;andrewid.txt&gt;</code>, for your Andrew ID. For example, if your Andrew ID is <code>satoshi</code>, then your proof goal will be:</p> <pre><code>... |- #root says open(#satoshi, &lt;satoshi.txt&gt;)\n</code></pre> <p>The context, or assumptions left of the turnstile, that your prover will be given, is populated automatically from the certificates and credentials distributed with the lab (discussed later). You should be able to use the credential in <code>andrewid_txt.cred</code> to discharge this goal. The credential consists of the following:</p> <pre><code>sign((open(#andrewid, &lt;andrewid.txt&gt;)), [2b:8f:e8:9b])\n</code></pre> <p>Your next objective will be the basic delegation policy, issued in <code>policy1.cred</code>:</p> <pre><code>sign(((@A . (((#mfredrik says open(A, &lt;shared.txt&gt;)) -&gt; open(A, &lt;shared.txt&gt;))))), [2b:8f:e8:9b])\n</code></pre> <p>Your prover should use this policy to prove that you can open <code>&lt;shared.txt&gt;</code>:</p> <pre><code>... |- #root says open(#andrewid, &lt;shared.txt&gt;)\n</code></pre> <p>To complete this goal, you will also need to use the fact that <code>#mfredrik</code> is authorized by <code>#root</code> to open <code>&lt;shared.txt&gt;</code>, issued in <code>mfredrik_shared.cred</code>.</p> <p>Finally, your prover will use the transitive delegation policy, also issued by <code>#root</code> in <code>policy2.cred</code>:</p> <pre><code>sign(((@A . ((@R . ((open(A, R) -&gt; (@B . (((A says open(B, R)) -&gt; open(B, R)))))))))), [2b:8f:e8:9b])\n</code></pre> <p>To prove that you can access <code>&lt;secret.txt&gt;</code>:</p> <pre><code>... |- #root says open(#andrewid, &lt;secret.txt&gt;)\n</code></pre> <p>To complete this objective, you will need to also make use of the chain of credentials from <code>#root -&gt; #mfredrik -&gt; #dsduenas -&gt; ... -&gt; #andrewid</code>.</p>"},{"location":"implementation/#recommended-work-it-on-paper-first","title":"Recommended: work it on paper first","text":"<p>Before moving on, we recommend that you work the following out on pencil and paper.</p> <ol> <li>Identify which of the certificates and credentials above are necessary to prove the first (and most straightforward) goal.</li> <li>Review using the <code>Cert</code> rule to prove <code>#ca says iskey(#root, [...])</code>.</li> <li>Review using the <code>Sign</code> rule to prove <code>#root says open(#andrewid, &lt;andrewid.txt&gt;)</code>.</li> <li>Put the pieces together to complete the proof of the first goal.</li> </ol> <p>As you complete each proof goal, we suggest going back to this approach whenever you find yourself getting stuck. If you come to the course staff with questions, we will likely ask to see your work before providing assistance.</p>"},{"location":"starter/","title":"Getting started","text":"<p>Clone this repository onto your local machine or your Andrew home directory.</p> <p>You will need to use Python 3.10 to complete this lab. You can reuse the virtual environment that you created for Lab 1. The only new dependency that you will need to complete the lab is the <code>cryptography</code> modulo, which you can install either via <code>pip</code> or <code>conda</code> from within your environment.</p> <pre><code>&gt; [pip|conda] install cryptography\n</code></pre> <p>You should then copy your private key, along with the credentials that you will need into the repository directory. Assuming <code>&lt;id&gt;</code> is your Andrew ID, run the following command:</p> <pre><code>scp -r &lt;id&gt;@linux.andrew.cmu.edu:/afs/andrew.cmu.edu/usr8/mfredrik/15316-f23/&lt;id&gt;/* .\n</code></pre>"},{"location":"starter/#credentials","title":"Credentials","text":"<p>You should now have a <code>credentials</code> directory with the following contents:</p> <pre><code>&lt;id&gt;_secret.cred\n&lt;id&gt;_shared.cred\n&lt;id&gt;_txt.cred\ndsduena_secret.cred\njustinyo_secret.cred\nmdhamank_secret.cred\nmfredrik_secret.cred\nmfredrik_shared.cred\npolicy1.cred\npolicy2.cred\nsiruih_secret.cred\n</code></pre> <p>A credential is a formula expresses the policy intent of an agent, that is signed by their private key to provide authenticity. For example, <code>policy1.cred</code> contains the following:</p> <pre><code>{\n  \"p\": \"(@A . (((#mfredrik says open(A, &lt;shared.txt&gt;)) -&gt; open(A, &lt;shared.txt&gt;))))\",\n  \"signator\": \"#root\",\n  \"signature\": \"c397b1d047279a4f544ae7eecafed3939b2780bc4f61b443849ec62069ce2b8353c5805cb102753f9b309d12541cc25349cced3cb830a137e30610f677068d02\"\n}\n</code></pre> <p>Here, <code>p</code> contains the policy formula, <code>signator</code> refers to the agent who signed the formula, and the bytes of the actual digital signature are given in <code>signature</code>. We are more familiar working with credentials as <code>sign</code> formulas, and we can get such a formula from the credential, and pretty-print it using <code>util.stringify</code>:</p> <pre><code>&gt; import crypto, util\n&gt; cred = crypto.Credential.load_credential('credentials/policy1.cred')\n&gt; print(stringify(cred.sign_formula()))\nsign(((@A . (((#mfredrik says open(A, &lt;shared.txt&gt;)) -&gt; open(A, &lt;shared.txt&gt;))))), [2b:8f:e8:9b])\n</code></pre> <p>The second argument appearing in square brackets is a digest of the signer's public key.</p> <p>Each policy used in this lab has a corresponding credential; the details of those policies are described in the implementation section of this documentation. You do not need to worry about manually loading credentials in most cases, as <code>auth.load_all_credentials</code> will do it for you.</p>"},{"location":"starter/#certificates","title":"Certificates","text":"<p>You should now have a <code>certs</code> directory with the following files (assuming <code>&lt;id&gt;</code> is your Andrew ID).</p> <pre><code>&lt;id&gt;.cert\nca.cert\ndsduena.cert\njustinyo.cert\nmdhamank.cert\nmfredrik.cert\nroot.cert\nsiruih.cert\n</code></pre> <p>A certificate is a formula in which a certificate authority (identified by <code>#ca</code> in this lab) signs that a public key belongs to a given agent:</p> <pre><code>sign(iskey(#agent, [agent_key_fingerprint]), [ca_key_fingerprint])\n</code></pre> <p>A key fingerprint is a string that uniquely identifies a public key, for example <code>[68:d7:6c:b7:95:fb:a4:f7:a7:4f:12:44:6f:27:c5:40]</code>.</p> What's in a certificate?  Looking at `certs/root.cert`, the contents are as follows.  <pre><code>{\n  \"agent\": \"#root\",\n  \"cred\": {\n    \"p\": \"iskey(#root, [2b:8f:e8:9b:8b:76:37:a7:3b:7e:85:49:9d:87:7b:3b])\",\n    \"signator\": \"#ca\",\n    \"signature\": \"4c120014db10eade1ab7a14f6745c94067f13bb38e4424c8084c24688a062268db37a08f480f571c90700afae07070c96428965cd19d20d3d2f105231ee60706\"\n  },\n  \"public_key\": \"2d2d2d2d2d424547494e205055424c4943204b45592d2d2d2d2d0a4d436f77425159444b32567741794541506844563357384a466d45547767366d69396b416262484e2b5742506c4e586f743372486f36466e5430303d0a2d2d2d2d2d454e44205055424c4943204b45592d2d2d2d2d0a\"\n}\n</code></pre>  Notice that the actual formula is given in `cert.cred.p`, in addition to easily-accessible metadata such as which party's public key is being certified (`cert.agent = #root`) and who the CA is (`cert.cred.signator = ca`).  <p>  Additionally, certificate files contain the base64-encoded digital signature (`cert.cred.signature`), signed using the public key of `cert.cred.signator`, as well as the public key of `cert.agent` (in this case, `#root`) in `cert.public_key`. If `#root` were to sign a credential, then it could be verified using this public key."},{"location":"starter/#private-keys","title":"Private keys","text":"<p>Finally, in the <code>private_keys</code> directory, you should see:</p> <pre><code>&lt;id&gt;.pem\n</code></pre> <p>You do not need to worry about the specific details of private keys, and you will not need to work directly with them: the code handed out with this lab takes care of creating signatures and certificates from private keys that you have access to. The APIs for doing this are discussed in more detail in exploiting a vulnerability.</p>"},{"location":"starter/#authorization-logic","title":"Authorization Logic","text":"<p><code>logic.py</code> defines the authorization logic that we have discussed in class.  There are three types of constants: agents, keys, and resources. </p> <ul> <li><code>Agent</code> constants are prefixed with <code>#</code>.</li> <li><code>Key</code> constants appear between brackets <code>[]</code>.</li> <li><code>Resource</code> constants appear between angle brackets <code>&lt;&gt;</code>.</li> </ul> <p>In formulas, locations expecting a constant of a particular type can also recieve a variable, which is just an alphanumeric string that is not prefixed with any special characters.  Both of the following are syntactically valid formulas, where the first has three variables that are replaced by corresponding constants in the second.</p> <pre><code>A says open(B, R)\n#A says open(#B, &lt;R&gt;)\n</code></pre> <p>A parser is provided in <code>parser.py</code>, and we strongly recommend that you use the parser to construct formula objects, rather than building them manually from the constructors in <code>logic.py</code>.</p> <pre><code>&gt; parse('A says P')\nApp(op=&lt;Operator.SAYS: 7&gt;, arity=2, args=[Variable(id='A'), Variable(id='P')])\n</code></pre> <p>The logic supports universal quantifiers, and uses the <code>@</code> symbol for them. When parsing quantified formulas, note that you should surround the quantified formula with parentheses to avoid potential parser errors.  So the following may result in a parser error. </p> <pre><code>parse('@x . @y . open(x, y)')\n</code></pre> <p>It should be run as follows.</p> <pre><code>parse('@x . (@y . (open(x, y)))')\n</code></pre>"},{"location":"starter/#sequents-and-judgements","title":"Sequents and judgements","text":"<p>When building sequents, our authorization logic distinguishes between affirmation justdments and truth judgements. Truth judgements are denoted by writing <code>true</code> after a formula, and are represented by the <code>Proposition</code> class in <code>logic.py</code>.</p> <pre><code>&gt; parse('(P -&gt; Q) true')\nProposition(p=App(op=&lt;Operator.IMPLIES: 4&gt;, arity=2, args=[Variable(id='P'), Variable(id='Q')]))\n</code></pre> <p>Affirmation judgements are denoted by juxtaposing a principal, <code>aff</code>, and a formula.</p> <pre><code>&gt; parse('A aff P -&gt; Q')\nAffirmation(a=Variable(id='A'), p=App(op=&lt;Operator.IMPLIES: 4&gt;, arity=2, args=[Variable(id='P'), Variable(id='Q')]))\n</code></pre> <p>Sequents are expressed using <code>|-</code>, and accept either type of judgement on the right.</p> <pre><code>&gt; parse('P |- A aff P')\nSequent(gamma=[Proposition(p=Variable(id='P'))], delta=Affirmation(a=Variable(id='A'), p=Variable(id='P')))\n</code></pre> <p>Note that if you do not write <code>true</code> to expressly denote a truth judgement, the parser will assume that this was what you intended to do.</p> <pre><code>&gt; parse('P |- Q')\nSequent(gamma=[Proposition(p=Variable(id='P'))], delta=Proposition(p=Variable(id='Q')))\n</code></pre>"},{"location":"starter/#proof-rules","title":"Proof rules","text":"<p>The proof rules available in this logic are listed in <code>proofrules.py</code>.</p> <pre><code>@dataclass(eq=True, frozen=True)\nclass Rule:\n    premises: list[Sequent]\n    conclusion: Sequent\n    name: str\n</code></pre> <p>As one might expect, a rule is comprised of a list of premises, each its own sequent, and a conclusion sequent. The convention that we use for specifying premises and the conclusion is illustrated by the left implication rule.</p> <pre><code>Rule(\n    [\n        parse('|- P true'),\n        parse('Q true |- R true')\n    ],\n    parse('P -&gt; Q true |- R true'),\n    '-&gt;L'\n)\n</code></pre> <p>Proof rules and sequents are composed to build <code>Proof</code> objects.</p> <pre><code>@dataclass(eq=True, frozen=True)\nclass Proof:\n    premises: list[Proof | Sequent]\n    conclusion: Sequent\n    rule: Rule\n</code></pre> <p>Each step of a proof much refer to a <code>Rule</code> defined in <code>proofrules.py</code>; you should not invent your own rules to use in proofs. Proofs are generated by tactics in this lab (more on this later), but for the purposes of illustration, we can manually write the following proof to reflect and application of the left implication rule.</p> <pre><code>Proof(\n    [\n        parse('(c -&gt; d) -&gt; e |- a'),\n        parse('b, (c -&gt; d) -&gt; e |- f')\n    ],\n    parse('a -&gt; b, (c -&gt; d) -&gt; e |- f'),\n    impLeftRule\n)\n</code></pre> <p>The <code>stringify</code> helper from <code>util.py</code> will print this out nicely.</p> <pre><code>   ((c -&gt; d) -&gt; e) true |- a true  b true, ((c -&gt; d) -&gt; e) true |- f true\n-&gt;L ------------------------------------------------------------------------\n                (a -&gt; b) true, ((c -&gt; d) -&gt; e) true |- f true\n</code></pre> <p>Note that your proofs may become wider than your screen. You can specify the width that <code>stringify</code> should be limited to with the <code>pf_width</code> keyword argument, and it will split premises apart from the main proof and print them separately.</p> <pre><code>&gt; print(stringify(pf, pf_width=50))\n                          T.0  T.1\n-&gt;L --------------------------------------------------\n      (a -&gt; b) true, ((c -&gt; d) -&gt; e) true |- f true\n\nProof T.1:\nb true, ((c -&gt; d) -&gt; e) true |- f true\n\nProof T.0:\n((c -&gt; d) -&gt; e) true |- a true\n</code></pre> <p>Looking at the rules available in <code>proofrules.py</code>, most should be familiar from lecture. The exceptions are <code>impLeftAffRule</code>, <code>forallLeftAffRule</code>, and <code>affCutRule</code>.</p> <pre><code>impLeftAffRule = Rule(\n    [\n        parse('|- P true'),\n        parse('Q true |- A aff R')\n    ],\n    parse('P -&gt; Q true |- A aff R'),\n    '-&gt;L'\n)\n\nforallLeftAffRule = Rule(\n    [parse('P(e) |- A aff Q')],\n    parse('@x . P(x) |- A aff Q'),\n    '@L'\n)\n\naffCutRule = Rule(\n    [\n        parse('|- P true'),\n        parse('P true |- A aff Q')\n    ],\n    parse('|- A aff Q'),\n    'affcut'\n)\n</code></pre> <p>These rules are the same as their \"normal\" counterparts from lecture, but they match sequents with an affirmation judgement on the right. You are free to use these rules when constructing <code>Proof</code> objects, and doing so should make developing tactics less intricate, as you have more freedom to decide when to apply the right <code>says</code> rule.</p> Full grammar of the logic <pre><code>&lt;agent&gt;   ::= x                            // variable\n            | #a                           // constant\n\n&lt;key&gt;     ::= x                            // variable\n            | [k]                          // constant\n\n&lt;resource&gt; ::= x                           // variable\n            | &lt;r&gt;                          // constant\n\n&lt;formula&gt; ::= x                            // variable\n            | &lt;formula&gt; -&gt; &lt;formula&gt;       // implication\n            | &lt;agent&gt; says &lt;formula&gt;\n            | iskey(&lt;agent&gt;, &lt;key&gt;)\n            | sign(&lt;formula&gt;, &lt;key&gt;)\n            | ca(&lt;agent&gt;)\n            | open(&lt;agent&gt;, &lt;resource&gt;)\n            | @x . &lt;formula&gt;               // universal quantifier\n\n&lt;judgement&gt; ::= &lt;formula&gt; true             // proposition\n              | &lt;agent&gt; aff &lt;formula&gt;      // affirmation\n\n&lt;sequent&gt; ::= &lt;judgement&gt;* |- &lt;judgement&gt;\n</code></pre>"},{"location":"starter/#next-steps","title":"Next steps","text":"<p>Now that you're familiar with the building blocks needed to write authorization proofs, check out the authorization goals for the lab.</p>"},{"location":"tactics/","title":"The prover","text":"<p>Your task is to implement <code>prove</code> in <code>prover.py</code> to discharge each of the authorization goals described in the previous section. As discussed in lecture, your prover will make use of a set of tactics that you design to construct authorization proofs. A tactic is simply a class with the following signature:</p> <pre><code>class Tactic(ABC):\n\n    @abstractmethod\n    def apply(self, seq: Sequent) -&gt; set[Proof]:\n        return set([seq])\n</code></pre> <p>The <code>apply</code> method accepts a sequent, and generates a set of proofs. </p>"},{"location":"tactics/#getting-started","title":"Getting started","text":"<p>Begin by familiarizing yourself with the provided example tactics listed below, and read the  Chaining Tactics section below. Then, we recommend that you proceed roughly with the following steps.</p> <ol> <li>Implement the <code>CertTactic</code> whose behavior was described in the example from the previous section. Doing so should allow you to use <code>ThenTactic</code> to complete the first authorization proof goal of the lab.</li> <li>Develop a tactic that allows you to take advantage of the first delegation policy, which contains a single universal quantifier. You may use <code>InstantiateForallTactic</code>, but it may help to first attempt the proof manually to see how to use this tactic effectively. This will allow you to develop a <code>ThenTactic</code> that handles the second authorization proof goal, possibly using tactics that you developed for step 1.</li> <li>Start a manual proof of the third authorization goal. Closing it out will be tedious, but likely unnecessary in order to gain enough insight to plan a tactic for this goal. To minimize the amount of additional work required, look for ways to reuse the tactics that you developed for earlier goals.</li> </ol> <p>As you proceed, there are several things that may be helpful to keep in mind.</p> <ul> <li>Do not implement a prover that can handle more general delegation policies, or anything beyond the three goals of this lab. Your prover only needs to produce proofs for the policies and formulas given in the previous section, so don't do more work than necessary!</li> <li>When considering how to handle transitive delegation (i.e., the third authorization goal), look for ways to do \"work\" outside of tactics. For example, it may be wise to scan the assumptions in the sequent given to <code>prover</code> to first figure out which agents are involved in a delegation chain leading from <code>#root</code> to <code>#andrewid</code>, and use that information to determine which tactics to include in a sequence given to <code>ThenTactic</code>. This will allow the tactics themselves to be simpler and more narrowly-focused on making definite progress towards closing out a proof.</li> <li>Part of your grade will be calculated by the number of unnecessary credentials and certificates that your authorization requests contain: your proof should not rely on credentials that are not actually needed to make a successful authorization. You should consider this when designing tactics that deal with <code>sign(...)</code> formulas: they could all be converted to <code>says</code> formulas eagerly before doing anything else, but this would mean that your proof would always rely on every certificate and credential provided in the context. It is better to consider tactics that only make use of <code>sign</code> formulas when they are needed to make progress handling the delegation policy.</li> <li>It's fine to start small: write tactics that emulate the steps that you would take to complete a proof by hand, and test them early. Use these tactics as building blocks to handle more complex formulas, until you are able to complete the authorization requests described in the previous section.</li> </ul>"},{"location":"tactics/#provided-examples","title":"Provided examples","text":"<p>Several tactics are provided for you in <code>prover.py</code>. </p> <ul> <li><code>InstantiateForallTactic</code>: use the left universal quantifier rule to instantiate a quantified assumption with a chosen term to substitute in for the quantified variable. For example, a tactic constructed as <code>InstantiateForallTactic([Agent('#mfredrik')])</code> and applied to <code>@x . open(x, &lt;r&gt;) |- open(#andrewid, &lt;r&gt;)</code>, would yield a proof that applies <code>@L</code> once, ending with the (unclosed) sequent <code>open(#mfredrik, &lt;r&gt;) |- open(#andrewid, &lt;r&gt;)</code>.</li> <li><code>SignTactic</code>: apply the <code>Sign</code> rule to a specified <code>sign</code> formula in the assumptions, replacing it with the corresponding <code>says</code> formula. The docstring for this tactic provides an example of its use.</li> <li><code>RuleTactic</code>: apply a given proof rule, which is passed to the constructor. We detailed this tactic in lecture, and show examples of its use below.</li> <li><code>ThenTactic</code>: apply a given sequence of tactics to make progress towards closing a proof. This is the most important \"meta\" tactic that you will use, as it allows you to chain tactics together, mirroring the process that you would take to writing a proof manually.</li> <li><code>OrElseTactic</code>: given a sequence of tactics, apply them (in order) until one makes progress. Once progress has been made, exit the tactic.</li> </ul>"},{"location":"tactics/#chaining-tactics","title":"Chaining Tactics","text":"<p>Although we did not describe it as such, we have been using tactics throughout the semester when we demonstrate reasoning using formal inference rules and sequent proofs. For example, to write a proof for the sequent:</p> <pre><code>R |- P -&gt; Q -&gt; R\n</code></pre> <p>You may immediately think, \"apply the right implication rule twice, and then apply the identity rule to close the proof\". This approach is formalized by composing <code>ThenTactic</code> with several instances of <code>RuleTactic</code>.</p> <pre><code>t = ThenTactic([\n    RuleTactic(impRightRule),\n    RuleTactic(impRightRule),\n    RuleTactic(identityRule)\n])\n</code></pre> <p>Applying the above tactic to the sequent in question yields a losed proof.</p> <pre><code>                          *\n      id ------------------------------------\n           Q true, P true, R true |- R true\n   -&gt;R ------------------------------------------\n           R true, P true |- (Q -&gt; R) true\n-&gt;R -------------------------------------------------\n            R true |- (P -&gt; (Q -&gt; R)) true\n</code></pre> <p>Under the hood, <code>ThenTactic</code> accomplishes this by chaining incomplete proofs together. After applying the first <code>RuleTactic(impRightRule)</code>, the (single) resulting proof is:</p> <pre><code>   P true, R true |- (Q -&gt; R) true\n-&gt;R ---------------------------------\n    R true |- (P -&gt; (Q -&gt; R)) true\n</code></pre> <p><code>ThenTactic</code> checks to see if this proof has any unclosed branches, and finds that there is one branch that progress can be made on by applying the next rule.</p> <pre><code>P true, R true |- (Q -&gt; R) true\n</code></pre> <p>Applying the next tactic passed to <code>ThenTactic</code>, to attempt a proof of the sequent directly above, yields another unfinished proof.</p> <pre><code>   P true, R true, Q true |- R true\n-&gt;R ----------------------------------\n    P true, R true |- (Q -&gt; R) true\n</code></pre> <p><code>ThenTactic</code> finds the unfinished premise, and applies the final <code>RuleTactic(identityRule)</code>, to close it out.</p> <pre><code>                    *\nid ------------------------------------\n     P true, R true, Q true |- R true\n</code></pre> <p>Each time that <code>ThenTactic</code> applies the next tactic to derive a proof for an open branch, it substitutes the unfinished branch with that proof. For example, <code>P true, R true, Q true |- R true</code> from the penultimate proof is substituted with the proof directly above to work, in a backwards fashion, towards the original goal.</p> <pre><code>                       *\n   id ------------------------------------\n        Q true, P true, R true |- R true\n-&gt;R ------------------------------------------\n        P true, R true |- (Q -&gt; R) true\n</code></pre> <p>Chaining this proof with the original unfinished branch, <code>P true, R true |- (Q -&gt; R) true</code>, completes the proof.</p> <p>This approach can also be used to transform assumptions to the left of the sequent. Suppose that we have in our assumptions <code>iskey(#ca, [kca])</code>, <code>sign((iskey(#root, [kr])), [kca])</code>, and <code>sign((open(#a, &lt;a.txt&gt;)), [kr])</code>. We want to prove that <code>#root says open(#a, &lt;a.txt&gt;)</code>. If we were to implement a <code>CertTactic</code>, which takes an agent named in a certificate, their public key fingerprint, an agent who is a certificate authority, and the authority's public key certificate, then we might attempt to prove this goal with the following tactic.</p> <pre><code>t = ThenTactic([\n    SignTactic(parse('sign(iskey(#root, [kr]), [kca])'), Agent('#ca')),\n    CertTactic(Agent('#root'), Key('[kr]'), Agent('#ca'), Key('[ca]')),\n    SignTactic(parse('sign((open(#a, &lt;a.txt&gt;)), [kr])'), Agent('#root')),\n    RuleTactic(identityRule)\n])\n</code></pre> <p>Now we can think through the steps that <code>ThenTactic</code> will take. First applying <code>SignTactic</code> will yield a proof with two branches, <code>T.0</code> and <code>T.1</code>.</p> <pre><code>                                                           T.0  T.1\ncut --------------------------------------------------------------------------------------------------------------------------\n      iskey(#ca, [kca]), sign((iskey(#root, [kr])), [kca]), sign((open(#a, &lt;a.txt&gt;)), [kr]) |- #root says open(#a, &lt;a.txt&gt;)\n</code></pre> <p>The left branch <code>T.0</code> is a short proof that uses the <code>Sign</code> rule to prove <code>(#ca says iskey(#root, [kr]))</code> from the assumptions listed above. This branch is already closed, because <code>iskey(#ca, [kca])</code> and <code>sign((iskey(#root, [kr]), [kca])</code> are already in the assumptions. The right branch <code>T.1</code>, on the other hand, is just the following sequent:</p> <pre><code>iskey(#ca, [kca]), sign((open(#a, &lt;a.txt&gt;)), [kr]), (#ca says iskey(#root, [kr])) |- (#root says open(#a, &lt;a.txt&gt;))\n</code></pre> <p><code>ThenTactic</code> will apply the next tactic to continue making progress on it, but observe that the formula <code>sign((iskey(#root, [kr]), [kca])</code> has been replaced with <code>#ca says iskey(#root, [kr])</code>. This is useful, because the <code>Cert</code> rule has as a premise that if we want to derive <code>iskey(#root, [kr])</code>, then we need to prove <code>ca(#ca)</code> and <code>#ca says iskey(#root, [kr])</code>. Thus, to implement <code>CertTactic</code>, we want its <code>apply</code> method to take a sequent like the one above, and produce a proof like the following:</p> <pre><code>                                                        T.0  T.1\ncut -------------------------------------------------------------------------------------------------------------------\n      iskey(#ca, [kca]), sign((open(#a, &lt;a.txt&gt;)), [kr]), #ca says iskey(#root, [kr]) |- #root says open(#a, &lt;a.txt&gt;)\n</code></pre> <p>Where <code>T.0</code> is a short, closed proof that applies the <code>Cert</code> rule to prove <code>iskey(#root, [kr])</code>, and <code>T.1</code> is the following sequent which incorporates that result as an assumption:</p> <pre><code>iskey(#ca, [kca]), sign((open(#a, &lt;a.txt&gt;)), [kr]), iskey(#root, [kr]) |- #root says open(#a, &lt;a.txt&gt;)\n</code></pre> <p>This allows <code>ThenTactic</code> to apply the next tactic, <code>SignTactic(parse('sign((open(#a, &lt;a.txt&gt;)), [kr])'), Agent('#root'))</code>, to this sequent, yielding a new branch:</p> <pre><code>iskey(#ca, [kca]), #root says open(#a, &lt;a.txt&gt;), iskey(#root, [kr]) |- #root says open(#a, &lt;a.txt&gt;)\n</code></pre> <p>Finally, <code>ThenTactic</code> can close this one remaining branch with <code>RuleTactic(identityRule)</code>, and chain the intermediate proofs together to finish up.</p> <p>This is the approach that you should aim to take when developing your solution: write short, narrowly-focused tactics that can be combined with others using <code>ThenTactic</code> to complete proofs for each of the three goals. Develop insights for which tactics you need to write from your experience working through proofs manually, so that the sequence of tactics that you give to <code>ThenTactic</code> mirror your knowledge of how to complete sequent proofs of authorization logic formulas.</p>"},{"location":"tactics/#tip-dont-forget-to-cut","title":"Tip: don't forget to <code>Cut</code>","text":"<p>In lecture we mentioned that the authorization logic does not need the <code>Cut</code> rule: any proof that uses <code>Cut</code> can be rewritten without it. However, your tactics are free to produce proofs that use <code>Cut</code>, and you may find that it is more straightforward to use <code>Cut</code> when the <code>Sign</code> and <code>Cert</code> rules are needed than otherwise. Consider the following sequent, which we will refer to as <code>seq1</code>.</p> <pre><code>ca(#ca),\niskey(#ca, [k1]),\nsign(iskey(#a, [k2]), [k1]),\nsign(iskey(#b, [k3]), [k1]),\nsign((#a says open(#c, &lt;r&gt;)) -&gt; open(#c, &lt;r&gt;), [k3])\nsign(open(#c, &lt;r&gt;), [k2])\n    |- #b says open(#c, &lt;r&gt;)\n</code></pre> <p>A proof for this needs to accomplish the following.</p> <ol> <li>\"Unwrap\" the certificates <code>sign(iskey(#a, [k2]), [k1])</code> and <code>sign(iskey(#b, [k3]), [k1])</code> to establish that <code>[k2]</code> belongs to <code>#a</code> and <code>[k3]</code> belongs to <code>#b</code>. Doing so entails obtaining <code>#ca says iskey(#a, [k2])</code> and <code>#ca says iskey(#b, [k3])</code> using the <code>Sign</code> rule.</li> <li>Obtain <code>#b says ((#a says open(#c, &lt;r&gt;)) -&gt; open(#c, &lt;r&gt;))</code> and <code>#a says open(#c, r)</code>.</li> <li>Make use of the previous two formulas to get <code>#b says open(#c, &lt;r&gt;)</code>.</li> </ol> <p>The rules that are needed for (1) are <code>Cert</code> and <code>Sign</code>. The <code>Cert</code> rule applies when we have an <code>iskey(A, [k])</code> judgement on the right of the sequent. Likewise, <code>Sign</code> applies when we have <code>A says P</code> judgements on the right. This is true in our case, as we are trying to prove <code>#b says open(#c, &lt;r&gt;)</code>, but we also want to obtain <code>#a says open(#c, &lt;r&gt;)</code> from the formula signed by <code>[k2]</code>, and in any event, we can't use <code>Sign</code> directly to obtain <code>#b says open(#c, &lt;r&gt;)</code> because <code>#b</code> did not directly sign <code>open(#c, &lt;r&gt;)</code>.</p> <p>The way to deal with this is to use <code>Cut</code> to formulate each goal that we need (and are able to prove from the existing assumptions), so that they become available in our assumptions for the rest of the proof. We could start by proving <code>#ca says iskey(#a, [k2])</code>.</p> <pre><code>p1 = Proof([p2, p3], parse('iskey(#ca, [k1]), sign(iskey(#a, [k2]), [k1]) |- #ca says iskey(#a, [k2])'), signRule)\n</code></pre> <p>The two premises of this proof themselves are proofs, which just apply the identity rule to show <code>iskey(#ca, [k1])</code> and <code>sign(iskey(#a, [k2]), [k1])</code>, respectively.</p> <pre><code>p2 = Proof([], parse('iskey(#ca, [k1]) |- iskey(#ca, [k1])'), identityRule)\np3 = Proof([], parse('sign(iskey(#a, [k2]), [k1]) |- sign(iskey(#a, [k2]), [k1])'), identityRule)\n</code></pre> <p>This gives us a proof that <code>#ca says iskey(#a, [k2])</code>, which we will need when applying the <code>Cert</code> rule to ultimately prove <code>iskey(#a, [k2])</code>. Let <code>seq2</code> be the following sequent, from which we can continue with the proof after using <code>Cut</code> to establish <code>#ca says iskey(#a, [k2])</code>.</p> <pre><code>ca(#ca),\niskey(#ca, [k1]),\n#ca says iskey(#a, [k2])\nsign(iskey(#b, [k3]), [k1]),\nsign((#a says open(#c, &lt;r&gt;)) -&gt; open(#c, &lt;r&gt;), [k3])\nsign(open(#c, &lt;r&gt;), [k2])\n    |- #b says open(#c, &lt;r&gt;)\n</code></pre> <p>The application of <code>Cut</code> is as follows.</p> <pre><code>Proof([p1, seq2], seq1, cutRule)\n</code></pre> <p>We can now continue the proof by working on <code>seq2</code>. The next step may be to apply <code>Cut</code> again, using the new assumption in <code>seq2</code> to prove <code>iskey(#a, [k2])</code> using <code>Cert</code>, so that it is available in the assumptions in the next sequent, in the right premise of that application of <code>Cut</code>.</p> <p>Before moving on, careful readers may have noticed that the assumptions in the sequent proved in <code>p1</code> are a subset of those in our original goal, <code>seq1</code>. Technically, we would need to apply a rule (weakening) several times to remove certain assumptions before this would be allowed. In this lab, tactics may produce proofs that apply weakening (i.e., remove assumptions) without a corresponding step in the proof; the verifier will not reject this. This makes proofs shorter and easier to read when printed to standard output, and thus hopefully easier to debug.</p>"},{"location":"testing/","title":"Testing your prover","text":"<p>The starter code in <code>prover.py</code> is configured to run your implementation of <code>prove</code> on a set of smaller tests in <code>prover_tests.txt</code> when invoked from the command line from the root of this repository.</p> <pre><code>&gt; python src/prover.py\n</code></pre> <p>These tests are not graded, but they may be helpful when developing specific tactics as they have fewer assumptions, and require fewer proof steps to complete. The recommended way to use these tests is to start from the simpler formulas, develop tactics that can be sequenced together to complete them. Look to incrementally add functionality until you are able to complete the tests near the end of <code>prover_tests.txt</code>, which are qualitatively similar to the real proof goals of the lab. Note that when your <code>prove</code> function is able to complete the more realistic tests near the end, it may fail on earlier tests that look very different (e.g., cases that have <code>says</code> instead of <code>sign</code> formulas in their assumptions). This is expected, and you are not graded on these test cases.</p> <p>Note that as you complete more of the lab, your prover may not be configured to solve each of the sequents in <code>prover_tests.txt</code> directly, as they look </p> <p>When you believe that your prover is able to handle the actual delegation policies, run <code>auth.py</code>, giving it an <code>agent</code> and a <code>resource</code> as arguments: </p> <pre><code>&gt; python src/auth.py agent resource\n</code></pre> <p>it gathers the assumptions discussed in the previous section into a context <code>Gamma</code>, constructs the sequent <code>Gamma |- #root says open(#agent, &lt;resource&gt;)</code>, and calls your prover. If your prover finds a proof, then <code>auth.py</code> scans the proof to determine which credentials and certificates it uses, and constructs an authorization request containing your proof along with all of the necessary credentials and certificates to verify it.</p> <p>You may run <code>auth.py</code> with the <code>-s</code> flag, and a request will be sent to an authorization server. If your proof verifies, and all of the credentials check out, then you will recieve a credential back from the server letting you know that <code>#root</code> grants access.</p> <p>For reference, the following three commands correspond to the proof goals for this lab:</p> <pre><code>&gt; python src/auth.py -s andrewid andrewid.txt\n&gt; python src/auth.py -s andrewid shared.txt\n&gt; python src/auth.py -s andrewid secret.txt\n</code></pre> <p>If you see credentials like the following, then you have successfully completed this part of the lab.</p> <pre><code>************************ Credential ************************\nstatement: open(#andrewid, &lt;secret.txt&gt;)\nsignator: #root\nsignature: [63:7f:5f:b7:11:4e:b8:e7:55:dd:96:01:8d:13:88:75]\n************************************************************\n</code></pre>"},{"location":"utility/","title":"Utility code","text":"<p>Before developing your implementation, you should have a look in <code>util.py</code>. This file contains several utility functions that are likely to be helpful with the tasks described above.</p> <ul> <li><code>allvars</code>, <code>allkeys</code>, <code>agents</code>, and <code>resources</code> return sets of variables, keys, agents, or resources contained in formulas, sequents, and proofs.</li> <li><code>fresh_var</code> returns a fresh variable that is not named within a formula, sequent, or proof.</li> <li><code>is_ca_key</code> scans a sequent to determine whether a specified key belongs to a certificate authority.</li> <li><code>get_cas</code> scans a sequent to return the set of agents named as certificate authorities by the <code>ca(*)</code> predicate.</li> <li><code>get_ca_key</code> scans a sequent to find the set of public key fingerprints that are associated with certificate authorities.</li> <li><code>is_key</code> scans a sequent to determine whether a public key fingerprint is associated with a specified agent.</li> <li><code>is_credential</code> scans a sequent to determine whether a given formula is a credential signed by a specified agent.</li> <li><code>has_credential</code> scans a sequent to determine whether a credential for a given formula, signed by a specified agent, exists in the context.</li> <li>There are <code>*_stringify</code> functions for formulas, sequents, and proofs. The function <code>stringify</code> function can be called on any of these objects, and dispatches to the correct stringifier.</li> <li>When calling <code>stringify</code> on a proof, you can pass the optional argument <code>trunc_context=True</code> to print the proof without the context (i.e., <code>gamma</code>) portion of sequents. This can make it easier to follow and debug when attempting to prove sequents with many assumptions.</li> </ul>"}]}